@using DragonSpark.Application.Entities.Queries.Runtime.Shape
@using DragonSpark.Compose
@typeparam T

@Fragment

@code {

	[Parameter]
	public IEvaluate<T> Input
	{
		get => _input;
		set
		{
			if (_input != value)
			{
				_input = value;
				Fragment = null;
			}
		}

	}

	[Parameter]
	public bool IncludeTotalCount
	{
		get => _includeTotalCount;
		set
		{
			if (_includeTotalCount != value)
			{
				_includeTotalCount = value;
				Fragment = null;
			}
		}
	}

	[Parameter]
	public string? OrderBy
	{
		get => _orderBy;
		set
		{
			if (_orderBy != value)
			{
				_orderBy = value;
				Fragment = null;
			}
		}
	}

	[Parameter]
	public string? Filter
	{
		get => _filter;
		set
		{
			if (_filter != value)
			{
				_filter = value;
				Fragment = null;
			}
		}
	}

	[Parameter]
	public Partition? Partition
	{
		get => _partition;
		set
		{
			if (_partition != value)
			{
				_partition = value;
				Fragment = null;
			}
		}

	}

	RenderFragment? Fragment { get; set; }

	protected override async Task OnParametersSetAsync()
	{
		Fragment ??= await DetermineFragment();
	}

	async ValueTask<RenderFragment> DetermineFragment()
	{
		Fragment = LoadingTemplate; // Account for re-entry
		var queryInput = new QueryInput
		{
			Filter = Filter, OrderBy = OrderBy, IncludeTotalCount = IncludeTotalCount, Partition = Partition
		};
		var current = await Input.Await(queryInput);
		var result = ChildContent(current);
		return result;
	}

	[Parameter]
	public RenderFragment<Current<T>> ChildContent { get; set; } = default!;

	[Parameter]
	public RenderFragment LoadingTemplate { get; set; } = DefaultLoadingTemplate.Default;

	IEvaluate<T> _input = default!;
	bool _includeTotalCount;
	string? _orderBy;
	string? _filter;
	Partition? _partition;
}