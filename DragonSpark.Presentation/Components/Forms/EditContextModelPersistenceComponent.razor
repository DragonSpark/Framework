@typeparam T where T : class
@using DragonSpark.Compose
@using DragonSpark.Model.Results
@using DragonSpark.Model.Sequences
@using DragonSpark.Presentation.Components.Eventing

@inherits ModelPersistenceComponentBase<T>
@implements IDisposable

@inject IPublisher<SaveModelMessage> Save

@code {
    readonly Switch _save  = new();
    Array<string>   _skip  = Array<string>.Empty;
    T               _model = default!;
    EditContext?    _current;

    protected override T DetermineModel() => _model;

    protected override void OnParametersSet()
    {
        var context = ResolvedContext;
        if (_current != context)
        {
            if (_current is not null)
            {
                _current.OnFieldChanged -= FieldChanged;
            }

            if ((_current = context) != null)
            {
                _current.OnFieldChanged += FieldChanged;
                _model = Model ?? _current.Model.To<T>();
            }
        }

        base.OnParametersSet();
    }

    EditContext ResolvedContext
        => (EditContext ?? ParentEditContext).Verify($"Edit Context is required for {GetType().Name}");

    [Parameter]
    public bool Enabled { get; set; } = true;

    [Parameter]
    public EditContext? EditContext { get; set; }

    [Parameter]
    public string FieldsToSkip
    {
        get => _fieldsToSkip;
        set
        {
            if (_fieldsToSkip != value)
            {
                _fieldsToSkip = value;
                _skip         = _fieldsToSkip.Split(',', StringSplitOptions.RemoveEmptyEntries);
            }
        }
    }   string _fieldsToSkip = default!;

    [CascadingParameter]
    EditContext? ParentEditContext { get; set; }

    void FieldChanged(object? sender, FieldChangedEventArgs args)
    {
        if (Enabled && !_skip.Open().Contains(args.FieldIdentifier.FieldName) && _save.Up())
        {
            StateHasChanged();
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
        => _save.Down() ? Save.Allocate(new(_model)) : base.OnAfterRenderAsync(firstRender);

    public void Dispose()
    {
        if (_current is not null)
        {
            _current.OnFieldChanged -= FieldChanged;
        }
    }
}