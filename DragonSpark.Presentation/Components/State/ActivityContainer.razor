@using DragonSpark.Compose
@using DragonSpark.Model.Results
@using DragonSpark.Presentation.Environment.Browser.Document
@rendermode InteractiveServer
@inherits Components.ComponentBase

@implements IActivityReceiver
@implements IAsyncDisposable

@inject IFocusedElement Focus

<div class="@_outer">
    <div class="@_class">
        <fieldset disabled="@Active">
            <CascadingValue TValue="IActivityReceiver" Value="@this" ChildContent="@_content" IsFixed="true" />
        </fieldset>
    </div>
    @if (Active && _display?.Message is not null)
    {
        <div class="position-absolute top-0 d-flex w-100 h-100 flex-column align-items-center justify-content-center">
            <div class="d-flex gap-2">
                <div class="spinner-border" role="status"></div>
                <div>@(_displaying ? "Please wait..." : _display?.Message)</div>
            </div>
            @if (_display?.Handle is not null && !_displaying)
            {
                <ul class="actions">
                    <li><button class="small button" disabled="@_displaying" @onclick="@OnCancel">Cancel</button></li>
                </ul>
            }
        </div>
    }
</div>

@code
{
    readonly Switch        _rendered = new(), _restore = new(), _displaying = new();
    string?                _class,               _outer;
    ActivityReceiverInput? _display;
    RenderFragment         _content = default!;

    protected override void OnInitialized()
    {
        Monitor?.Add.Execute(this);
        _content = ChildContent(this);
        base.OnInitialized();
    }

    [Parameter]
    public string CssClass { get; set; } = string.Empty;

    [Parameter]
    public string ActiveStyle { get; set; } = "dragonspark-activity-active";

    [Parameter]
    public RenderFragment<IActivityReceiver> ChildContent { get; set; } = default!;

    [CascadingParameter] IActivityMonitor? Monitor { get; set; }

    string? Class()
    {
        var start  = Active ? $"{ActiveStyle} {CssClass}" : CssClass;
        var result = start.Trim().NullIfEmpty();
        return result;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _rendered.Up();
        if (_restore.Down())
        {
            await Focus.Restore.Get();
            if (Monitor is not null)
            {
                await Monitor.Await();
            }
        }
    }

    public bool Active { get; private set; }

    bool Update() => Update(_display);

    bool Update(ActivityReceiverInput? parameter)
    {
        var active = ActiveState.Default.Get(this);
        var result = active != Active;
        if (result)
        {
            Active = active;
            _class = Class();
            _outer = active && parameter?.Message is not null ? "position-relative" : string.Empty;
        }
        return result;
    }

    public async ValueTask Start(ActivityReceiverInput parameter)
    {
        if (Update(parameter))
        {
            _display = parameter;

            if (_rendered)
            {
                await Focus.Store.Get();
            }
            if (Monitor is not null)
            {
                await Monitor.Await();
            }
        }
    }

    public async ValueTask Complete()
    {
        var update = Update();
        _restore.Execute(update);
        if (update)
        {
            _displaying.Down();

            if (Monitor is not null)
            {
                await Monitor.Await();
            }
        }
    }

    Task OnCancel()
    {
        var handle = _display?.Handle;
        if (handle is not null)
        {
            _displaying.Up();
            return handle.Allocate();
        }
        return Task.CompletedTask;
    }

    public ValueTask DisposeAsync()
    {
        Monitor?.Remove.Execute(this);
        return Focus.DisposeAsync();
    }
}