@using DragonSpark.Compose
@using DragonSpark.Model.Commands
@using DragonSpark.Model.Results
@using DragonSpark.Presentation.Environment.Browser.Document
@using NetFabric.Hyperlinq
@using System.Buffers

@inherits Components.ComponentBase

@implements IActivityReceiver
@implements IAsyncDisposable

@inject IFocusedElement Focus

<div class="@_outer">
    <div class="@_class">
        <fieldset disabled="@Active">
            <ShouldRenderComponent Enabled="@Render">
                <CascadingValue TValue="IActivityReceiver" Value="@this" IsFixed="true" ChildContent="@_content" />
            </ShouldRenderComponent>
        </fieldset>
    </div>
    @if (Active && _previous.Current is CancelAwareActivityOptions cancel)
    {
        <div class="position-absolute top-0 d-flex w-100 h-100 flex-column align-items-center justify-content-center">
            <div class="d-flex gap-2">
                <div class="spinner-border" role="status"></div>
                <div>@(_displaying ? "Please wait..." : cancel.Message)</div>
            </div>
            @if (!_displaying)
            {
                <ul class="actions">
                    <li><button class="small button" disabled="@_displaying" @onclick="@OnCancel">Cancel</button></li>
                </ul>
            }
        </div>
    }
</div>

@code
{
    readonly List<IRenderAware> _renderings = new();
    readonly Switch             _start      = false, _restore = false, _displaying = false, _render = true;
    ActivityReceiverModel       _previous   = null!;
    RenderFragment              _content    = null!;
    string?                     _class, _outer;

    protected override void OnInitialized()
    {
        _previous = new(new(_renderings));
        _content  = ChildContent(this);
        Monitor?.Add.Execute(this);
        base.OnInitialized();
    }

    [Parameter]
    public string CssClass { get; set; } = string.Empty;

    [Parameter]
    public string ActiveStyle { get; set; } = "dragonspark-activity-active";

    [Parameter]
    public RenderFragment<IActivityReceiver> ChildContent { get; set; } = null!;

    [CascadingParameter] IActivityMonitor? Monitor { get; set; }

    string? Class()
    {
        var start  = Active ? $"{ActiveStyle} {CssClass}" : CssClass;
        var result = start.Trim().NullIfEmpty();
        return result;
    }

    bool Render
    {
        get
        {
            var render = !Active && (_render || !_render.Up());
            return render;
        }
    }

    public bool Active => _previous.Active;

    void Update() => Update(_previous.Current);

    void Update(ActivityOptions? parameter)
    {
        _class = Class();
        _outer = Active && parameter is CancelAwareActivityOptions ? "position-relative" : null;
    }

    public async ValueTask Get(ActivityReceiverState parameter)
    {
        await _previous.On(parameter);
        Update();
        if (_start && !_restore)
        {
            await Focus.Store.On();
        }

        if (parameter.Options.RedrawOnStart)
        {
            StateHasChanged();
        }
        else
        {
            if (Monitor is not null)
            {
                await Monitor.On();
            }

            using var renderings = _renderings.AsValueEnumerable().ToArray(ArrayPool<IRenderAware>.Shared);
            foreach (var i in renderings)
            {
                i.Execute();
            }
        }
    }

    public async ValueTask<ActivityReceiverState?> Get()
    {
        var result = await _previous.On();
        Update(result?.Options);
        if (result is not null)
        {
            _restore.Up();
            _displaying.Down();

            if (Monitor is not null)
            {
                await Monitor.On();
            }

            switch (result.Value.Options.PostRenderAction)
            {
                case PostRenderAction.ForceRedraw:
                    StateHasChanged();
                    break;
                case PostRenderAction.DeferredRedraw:
                    _render.Down();
                    break;
            }
        }
        return result;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _start.Up();
        if (!Active && _restore.Down())
        {
            await Focus.Restore.On();
            if (Monitor is not null)
            {
                await Monitor.Off();
            }
        }
    }


    Task OnCancel()
    {
        if (_previous.Current is CancelAwareActivityOptions cancel)
        {
            _displaying.Up();
            return cancel.Handle.Allocate();
        }
        return Task.CompletedTask;
    }

    public ICommand<IRenderAware> Add => _previous.Add;

    public ICommand<IRenderAware> Remove => _previous.Remove;

    public ValueTask DisposeAsync()
    {
        Monitor?.Remove.Execute(this);
        return Focus.DisposeAsync();
    }
}