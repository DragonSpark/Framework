@using DragonSpark.Compose
@using DragonSpark.Model
@using DragonSpark.Model.Commands
@using DragonSpark.Model.Operations.Allocated
@using DragonSpark.Model.Results
@using DragonSpark.Model.Selection.Stores

@ChildContent(this)

@code {
    readonly HashSet<Switch> _monitored = new();
    readonly AllocatedTable  _monitors  = new();
    readonly ActionTable     _actions   = new();

    [Parameter]
    public RenderFragment<ProtectedCallbacks> ChildContent { get; set; } = default!;

    public EventCallback<T> Register<T>(Func<T, Task> parameter)
    {
        var monitor = Monitors<T>.Default.Get(this).Get(parameter);
        _monitored.Add(monitor.Target.Verify().To<Switch>());
        return new(this, monitor);
    }

    public EventCallback Register(Func<Task> parameter)
    {
        var monitor = _monitors.Get(parameter);
        _monitored.Add(monitor.Target.Verify().To<Switch>());
        return new(this, monitor);
    }

    public EventCallback<T> Register<T>(System.Action<T> parameter)
    {
        var monitor = Actions<T>.Default.Get(this).Get(parameter);
        _monitored.Add(monitor.Target.Verify().To<Switch>());
        return new(this, monitor);
    }

    public EventCallback Register(System.Action parameter)
    {
        var action = _actions.Get(parameter);
        _monitored.Add(action.Target.Verify().To<Switch>());
        return new(this, action);
    }

    public EventCallback Register(EventCallback parameter)
    {
        var callback = new Callback(parameter);
        _monitored.Add(callback);
        return parameter;
    }

    public override Task SetParametersAsync(ParameterView parameters)
    {
        _monitored.Clear();
        return base.SetParametersAsync(parameters);
    }

    protected override bool ShouldRender() => _monitored.All(x => x || !x.Up());

    sealed class Monitors<T> : ReferenceValueStore<object, AllocatedTable<T>>
    {
        public static Monitors<T> Default { get; } = new();

        Monitors() : base(_ => new()) {}
    }

    sealed class AllocatedTable : StandardTable<Func<Task>, Func<Task>>
    {
        public AllocatedTable() : base(x => A.Result<Task>(new Allocated(x)).Get) {}
    }

    sealed class AllocatedTable<T> : StandardTable<Func<T, Task>, Func<T, Task>>
    {
        public AllocatedTable() : base(x => A.Selection(new Allocated<T>(x)).Get) {}
    }

    sealed class Allocated<T> : Switch, IAllocated<T>
    {
        readonly Func<T, Task> _previous;

        public Allocated(Func<T, Task> previous) : base(true) => _previous = previous;

        public Task Get(T parameter)
        {
            this.Down();
            return _previous(parameter);
        }
    }
    sealed class Actions<T> : ReferenceValueStore<object, ActionTable<T>>
    {
        public static Actions<T> Default { get; } = new();

        Actions() : base(_ => new()) {}
    }

    sealed class ActionTable : StandardTable<System.Action, System.Action>
    {
        public ActionTable() : base(x => new Action(x).Execute) {}
    }

    sealed class ActionTable<T> : StandardTable<System.Action<T>, System.Action<T>>
    {
        public ActionTable() : base(x => new Action<T>(x).Execute) {}
    }
    sealed class Action<T> : Switch, ICommand<T>
    {
        readonly System.Action<T> _action;

        public Action(System.Action<T> action) : base(true) => _action = action;

        public void Execute(T parameter)
        {
            this.Down();
            _action(parameter);
        }
    }


    sealed class Action : Switch, ICommand
    {
        readonly System.Action _action;

        public Action(System.Action action) : base(true) => _action = action;

        public void Execute(None parameter)
        {
            this.Down();
            _action();
        }
    }

    sealed class Allocated : Switch, IAllocated
    {
        readonly Func<Task> _previous;

        public Allocated(Func<Task> previous) : base(true) => _previous = previous;

        Task IResult<Task>.Get()
        {
            this.Down();
            return _previous();
        }
    }

    sealed class Callback : Switch, IAllocated
    {
        readonly EventCallback _subject;

        public Callback(EventCallback subject) : base(true) => _subject = subject;

        Task IResult<Task>.Get()
        {
            this.Down();
            return _subject.Invoke();
        }
    }

}