@using DragonSpark.Compose
@using DragonSpark.Model
@using DragonSpark.Model.Commands
@using DragonSpark.Model.Operations.Allocated
@using DragonSpark.Model.Results
@using DragonSpark.Model.Selection
@using DragonSpark.Model.Selection.Stores

@ChildContent(this)

@code { // TODO: Remove
    readonly HashSet<Switch> _monitored = new();
    readonly AllocatedTable  _monitors  = new();
    readonly ActionTable     _actions   = new();
    readonly CallbackTable   _callbacks = new();

    [Parameter]
    public string Identifier { get; set; } = string.Empty;

    [Parameter]
    public RenderFragment<CallbackRenderGate> ChildContent { get; set; } = default!;

    public EventCallback<T> Register<T>(Func<T, Task> parameter)
    {
        var monitor = Monitors<T>.Default.Get(this).Get(parameter);
        _monitored.Add(monitor.Target.Verify().To<Switch>());
        return new(this, monitor);
    }

    public EventCallback Register(Func<Task> parameter)
    {
        var monitor = _monitors.Get(parameter);
        _monitored.Add(monitor.Target.Verify().To<Switch>());
        return new(this, monitor);
    }

    public EventCallback<T> Register<T>(System.Action<T> parameter)
    {
        var monitor = Actions<T>.Default.Get(this).Get(parameter);
        _monitored.Add(monitor.Target.Verify().To<Switch>());
        return new(this, monitor);
    }

    public EventCallback Register(System.Action parameter)
    {
        var action = _actions.Get(parameter);
        _monitored.Add(action.Target.Verify().To<Switch>());
        return new(this, action);
    }

    public EventCallback Register(EventCallback parameter)
    {
        var (@switch, callback) = _callbacks.Get(parameter);
        _monitored.Add(@switch);
        return callback;
    }

    public EventCallback<T> Register<T>(EventCallback<T> parameter)
    {
        var (@switch, callback) = Callbacks<T>.Default.Get(this).Get(parameter);
        _monitored.Add(@switch);
        return callback;
    }

    /*public override Task SetParametersAsync(ParameterView parameters)
    {
        //_monitored.Clear();
        return base.SetParametersAsync(parameters);
    }*/

    protected override bool ShouldRender()
    {
        var shouldRender = _monitored.All(x => x || !x.Up());
        return shouldRender;
    }

    sealed class Monitors<T> : ReferenceValueStore<object, AllocatedTable<T>>
    {
        public static Monitors<T> Default { get; } = new();

        Monitors() : base(_ => new()) {}
    }

    sealed class AllocatedTable : StandardTable<Func<Task>, Func<Task>>
    {
        public AllocatedTable() : base(x => A.Result<Task>(new Allocated(x)).Get) {}
    }

    sealed class AllocatedTable<T> : StandardTable<Func<T, Task>, Func<T, Task>>
    {
        public AllocatedTable() : base(x => A.Selection(new Allocated<T>(x)).Get) {}
    }

    sealed class Allocated<T> : Switch, IAllocated<T>
    {
        readonly Func<T, Task> _previous;

        public Allocated(Func<T, Task> previous) : base(true) => _previous = previous;

        public Task Get(T parameter)
        {
            this.Down();
            return _previous(parameter);
        }
    }

    sealed class Actions<T> : ReferenceValueStore<object, ActionTable<T>>
    {
        public static Actions<T> Default { get; } = new();

        Actions() : base(_ => new()) {}
    }

    sealed class ActionTable : StandardTable<System.Action, System.Action>
    {
        public ActionTable() : base(x => new Action(x).Execute) {}
    }

    sealed class ActionTable<T> : StandardTable<System.Action<T>, System.Action<T>>
    {
        public ActionTable() : base(x => new Action<T>(x).Execute) {}
    }

    sealed class Action<T> : Switch, ICommand<T>
    {
        readonly System.Action<T> _action;

        public Action(System.Action<T> action) : base(true) => _action = action;

        public void Execute(T parameter)
        {
            this.Down();
            _action(parameter);
        }
    }

    sealed class Action : Switch, ICommand
    {
        readonly System.Action _action;

        public Action(System.Action action) : base(true) => _action = action;

        public void Execute(None parameter)
        {
            this.Down();
            _action();
        }
    }

    sealed class Allocated : Switch, IAllocated
    {
        readonly Func<Task> _previous;

        public Allocated(Func<Task> previous) : base(true) => _previous = previous;

        Task IResult<Task>.Get()
        {
            this.Down();
            return _previous();
        }
    }

    sealed class CallbackTable : StandardTable<EventCallback, CallbackContext>
    {
        public CallbackTable() : base(x => new(x)) {}
    }

    sealed class CallbackTable<T> : StandardTable<EventCallback<T>, CallbackContext<T>>
    {
        public CallbackTable() : base(x => new CallbackContext<T>(x)) {}
    }

    readonly record struct CallbackContext(Switch Instance, EventCallback Subject)
    {
        public CallbackContext(EventCallback callback) : this(new Callback(callback)) {}

        public CallbackContext(Callback instance) : this(instance, An.Operation(instance).Then().Callback()) {}
    }

    readonly record struct CallbackContext<T>(Switch Instance, EventCallback<T> Subject)
    {
        public CallbackContext(EventCallback<T> callback) : this(new Callback<T>(callback)) {}

        public CallbackContext(Callback<T> instance) : this(instance, An.Operation(instance).Then().Callback()) {}
    }

    sealed class Callbacks<T> : ReferenceValueStore<object, CallbackTable<T>>
    {
        public static Callbacks<T> Default { get; } = new();

        Callbacks() : base(_ => new()) {}
    }

    sealed class Callback<T> : Switch, IAllocated<T>
    {
        readonly EventCallback<T> _subject;

        public Callback(EventCallback<T> subject) : base(true) => _subject = subject;

        Task ISelect<T, Task>.Get(T parameter)
        {
            this.Down();
            return _subject.Invoke(parameter);
        }
    }

    sealed class Callback : Switch, IAllocated
    {
        readonly EventCallback _subject;

        public Callback(EventCallback subject) : base(true) => _subject = subject;

        Task IResult<Task>.Get()
        {
            this.Down();
            return _subject.Invoke();
        }
    }

}