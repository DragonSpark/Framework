@using BlazorPro.BlazorSize
@using DragonSpark.Compose
@using DragonSpark.Model.Operations
@using DragonSpark.Presentation
@using DragonSpark.Presentation.Components.Content.Rendering
@using DragonSpark.SyncfusionRendering.Entities
@using DragonSpark.SyncfusionRendering.Queries
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using Microsoft.Extensions.Caching.Memory
@using Syncfusion.Blazor
@using Syncfusion.Blazor.Grids
@using Action = Syncfusion.Blazor.Grids.Action

@typeparam T
@inherits DataQueryComponent

@inject IMemoryCache Memory
@inject IContentKey Key
@inject ProtectedSessionStorage Session

<AdaptiveGrid T="T"
              @ref="@_subject"
              Id="@Id"
              Enabled="@_active"
              FilterType="@FilterType"
              Columns="@Columns"
              AllowSelection="@AllowSelection"
              AllowPaging="@AllowPaging"
              AllowFiltering="@AllowFiltering"
              AllowSorting="@AllowSorting"
              AllowExport="@AllowExport"
              Breakpoint="@Breakpoint"
              DesktopToolbar="@DesktopToolbar"
              MobileToolbar="@MobileToolbar"
              CssClass="@CssClass"
              PageSize="@PageSize"
              LoadingTemplate="@LoadingTemplate"
              @attributes="@AdditionalAttributes">

    <GridTemplates EmptyRecordTemplate="@EmptyTemplate"/>


    <GridEvents TValue="T" DataBound="OnDataBound" OnActionBegin="@OnActionBegin"/>
    <Syncfusion.Blazor.Data.SfDataManager Adaptor="Adaptors.CustomAdaptor">
        <DataRequestCallbackAdaptor Requested="@OnRequest"/>
    </Syncfusion.Blazor.Data.SfDataManager>
    @if (ChildContent is not null)
    {
        @ChildContent
    }
</AdaptiveGrid>

@code {
    readonly Model.Results.Switch _refresh = new(), _active = new(true);

    GridStateVariable _store = null!;
    AdaptiveGrid<T>? _subject;

    protected override void OnInitialized()
    {
        _store = new GridStateVariable(Id, Session);
        EmptyTemplate = LoadingTemplate.Accept;
        base.OnInitialized();
    }

    protected override void OnContentChanged(Await<DataManagerRequest, object>? parameter)
    {
        _refresh.Execute(parameter is not null);
    }

    public Task Export() => _subject?.Export() ?? Task.CompletedTask;

    [Parameter]
    public string Id { get; set; } = string.Empty;

    [Parameter]
    public FilterType FilterType { get; set; } = FilterType.Excel;

    [Parameter]
    public bool AllowExport { get; set; }

    [Parameter]
    public bool AllowSelection { get; set; }

    [Parameter]
    public RenderFragment Columns { get; set; } = default!;

    [Parameter]
    public string Breakpoint { get; set; } = Breakpoints.SmallUp;

    [Parameter]
    public RenderFragment EmptyElementsTemplate { get; set; } = DefaultEmptyResultTemplate.Default;

    [Parameter]
    public ICollection<string>? DesktopToolbar { get; set; }

    [Parameter]
    public ICollection<string>? MobileToolbar { get; set; } = DefaultToolbar.Default;

    [Parameter]
    public EventCallback<Updated<T>> Updated { get; set; }

    [Parameter]
    public EventCallback<Allow<T>> Editing { get; set; }

    [Parameter]
    public EventCallback<T> Created { get; set; }

    RenderFragment<EmptyRecordTemplateContext>? EmptyTemplate { get; set; }

    public Task Refresh() => _subject?.Refresh() ?? Task.CompletedTask;

    protected override Task OnParametersSetAsync()
        => _subject is not null && _refresh.Down() ? Refresh() : base.OnParametersSetAsync();

    protected override Await<DataManagerRequest, object> CreateInput()
    {
        var body = new StateAwareDataRequest(Content, _store, _active);
        var next = new MemoryAwareDataRequest(body, Memory, Key.Get(this));
        return next.Then().Then().Handle(EmptyDataResult.Default.Get());
    }

    void OnDataBound()
    {
        EmptyTemplate = EmptyElementsTemplate.Accept;
    }

    async Task OnActionBegin(ActionEventArgs<T> arg)
    {
        switch (arg.RequestType)
        {
            case Action.BeginEdit:
                var allow = new Allow<T>(arg.Data);
                await Editing.InvokeAsync(allow);
                arg.Cancel = !allow.Get();
                break;
            case Action.Add:
                await Created.InvokeAsync(arg.Data);
                break;
            case Action.Save:
            case Action.Delete:
                await Updated.InvokeAsync(new(arg.Data, arg.Action));
                break;
        }
    }

    protected override Task OnRequest(DataRequestResult parameter)
    {
        _refresh.Down();
        return base.OnRequest(parameter);
    }

}